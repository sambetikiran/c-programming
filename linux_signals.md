## 1. Can you explain the concept of signals in programming? How are they used in Unix
like operating systems? 

Signals are asynchronous notifications sent to a process to inform it of events such as interrupts or exceptions. In Unix-like systems, they are used to handle events like `Ctrl+C` (SIGINT) or illegal operations without continuous polling.

## 2. What are software interrupts and hardware interrupts and mention potential issues 
when dealing with them?

Hardware interrupts come from external devices like keyboards or timers, while software interrupts are generated by programs or system calls. Problems like race conditions, lost interrupts, or priority inversion may occur if not handled properly.

## 3. What is synchronous signal and asynchronous signal and how the process can be used for both?

Synchronous signals occur due to a processâ€™s own actions (like division by zero), whereas asynchronous signals come from external sources such as other processes. A process can use both by registering handlers for external signals and letting the kernel deliver internal ones.

## 4. Who is responsible for generating signals?

Signals can be generated by the kernel (for errors like segmentation faults), other processes (using the `kill()` system call), or hardware/terminal input (like pressing `Ctrl+C`).

## 5. What is signal handler?
   
A signal handler is a user-defined function that executes when a signal is received, allowing a process to take custom actions instead of following the default behavior like termination or ignoring the signal.

## 6. Which system call is used to send a signal to the process?
   
The `kill(pid, signal)` system call is used to send signals to a specific process, while `raise(signal)` can send a signal to the calling process itself.

## 7. Write a program to send a signal to itself (same process)?

A process can send a signal to itself using the `raise()` function, for example:

```c
raise(SIGUSR1);
```

This sends the SIGUSR1 signal to the same process.

## 8. Explain the default action associated with the SIGKILL signal?
   
The default action of `SIGKILL` is to immediately and unconditionally terminate a process; it cannot be caught, blocked, or ignored by the process.

## 9. How does a process handle a signal while it is executing in kernel mode?
    
When a process is in kernel mode, signals are held pending and delivered only after returning to user mode to ensure kernel operations are not interrupted.

## 10. Describe the behaviour of a process when it receives a SIGSEGV signal?

When a process receives a `SIGSEGV` signal due to invalid memory access, it terminates by default and may produce a core dump unless a custom handler is defined.
## 2. Implement a C program to send a custom signal to another process. 
```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

void handler(int sig) {
    printf("Received custom signal: %d (SIGUSR1)\n", sig);
    fflush(stdout); // ensure output appears immediately
}

int main() {
    signal(SIGUSR1, handler);
    printf("Waiting for SIGUSR1... (PID: %d)\n", getpid());
    fflush(stdout);

    while (1)
        pause();  // wait until a signal arrives

    return 0;
}
```
## 3. Create a C program to ignore the SIGCHLD signal temporarily. 
```c
#include<stdio.h>
#include<string.h>
#include<signal.h>
#include<stdlib.h>
#include<unistd.h>
#include<sys/wait.h>
int main()
{
        int pid;
        signal(SIGCHLD,SIG_IGN);
        pid=fork();
        if(pid==0)
        {
                printf("child process id is %d",getpid());
                exit(1);
        }
        printf("parent pid is %d",getpid());
        signal(SIGCHLD,SIG_DFL);
        sleep(2);
        wait(NULL);
}
```
## 4. Write a program to block the SIGTERM signal using sigprocmask().
```c
#include<stdio.h>
#include<signal.h>
#include<stdlib.h>
#include<unistd.h>
int main()
{
        sigset_t set;
        sigemptyset(&set);
        sigaddset(&set,SIGTERM);
        sigprocmask(SIG_BLOCK,&set,NULL);
        sleep(10);
        printf("pid is %d\n",getpid());
        sigprocmask(SIG_UNBLOCK,&set,NULL);
        sleep(2);
}
```
## 5. Implement a C program to handle the SIGALRM signal using sigaction().
```c
#include<stdio.h>
#include<string.h>
#include<unistd.h>
#include<stdlib.h>
#include<signal.h>
void signal_handler(int sig)
{
        printf("Waiting for SIGTERM signal... (PID: %d)\n", getpid());
        exit(0);
}
int main()
{
        signal(SIGTERM,signal_handler);
        printf("signal is terminate id is %d\n",getpid());
        while(1)
        {
                sleep(1);
        }
}
finally another terminal i have to give kill -TERM pid number
```
## 7. Implement a program to handle the SIGSEGV signal (segmentation fault). 
```c
#include<stdio.h>
#include<stdlib.h>
#include<signal.h>
#include<unistd.h>
void sgnl_hand()
{
        printf("segmentation default occure in pid %d",getpid());
        exit(0);
}
int main()
{
        signal(SIGSEGV,sgnl_hand);
        printf("occuring of segmentation fault\n");
        sleep(1);
        int *ptr=NULL;
        *ptr=10;
}
```
